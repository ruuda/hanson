{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hanson \u00b6 Hanson is a prediction market app. Self-hosted, free and open-source software. No real money, users trade virtual internet points. Designed for running internal prediction markets in organizations.","title":"index"},{"location":"#hanson","text":"Hanson is a prediction market app. Self-hosted, free and open-source software. No real money, users trade virtual internet points. Designed for running internal prediction markets in organizations.","title":"Hanson"},{"location":"accounts/","text":"Accounts \u00b6 Assets, as described in the assets section , can exists in multiple places. Points can live in two places: A market . We call this the market\u2019s capitalization . The points that are held with the market, are used to reward holders of outcome shares when the market resolves. In user\u2019s accounts . We call this the user\u2019s balance in points. Outcome shares can similarly live in two places: A market\u2019s market maker pool . Every market comes with an automated market maker ( AMM for short). Users can only trade with the market maker, not with eachother. The market maker maintains a pool of outcome shares to trade. If the market eventually settles on the actual outcome, the shares in the pool will be worth very little (users hold all of the valuable shares and made a profit), and the market maker makes a loss. In user\u2019s accounts . We call this the user\u2019s balance for the given outcome share.","title":"Accounts"},{"location":"accounts/#accounts","text":"Assets, as described in the assets section , can exists in multiple places. Points can live in two places: A market . We call this the market\u2019s capitalization . The points that are held with the market, are used to reward holders of outcome shares when the market resolves. In user\u2019s accounts . We call this the user\u2019s balance in points. Outcome shares can similarly live in two places: A market\u2019s market maker pool . Every market comes with an automated market maker ( AMM for short). Users can only trade with the market maker, not with eachother. The market maker maintains a pool of outcome shares to trade. If the market eventually settles on the actual outcome, the shares in the pool will be worth very little (users hold all of the valuable shares and made a profit), and the market maker makes a loss. In user\u2019s accounts . We call this the user\u2019s balance for the given outcome share.","title":"Accounts"},{"location":"assets/","text":"Assets \u00b6 There are two kinds of asset in Hanson: Points , the native currency, denoted with symbol \u201cpt\u201d. Points have no (intrinsic) value in the real world, they are virtual internet points. If Hanson were a real-money prediction market, the currency might have been Euros or Bitcoin. Outcome shares . Outcome shares are associated with a particular market. When the market resolves, outcome shares for the actual outcome will be converted into points, while the shares for the other outcomes become worthless. For every market, there is an exchange rate between outcome shares and points. It starts out at 1:1, but outcome shares can become more valuable due to subsidies. Outcome shares can be created from and destroyed for points, but only in equal quantities. For example, in a binary market with Y and N outcomes and 1:1 exchange rate, we can convert 1 pt into 1 Y + 1 N, and vice versa. This is because when the market resolves, either Y will become worth 1 pt and N worthless, or N will become worth 1 pt and Y worthless, so if you have 1 Y and 1 N, you effectively have 1 pt. Points can only be created by the system. The system creates points for two reasons: Income . Every user gets some points every day, to participate in the markets and create new ones. Think of it as pocket money, an allowance, or a basic income. Subsidies . Good markets can be subsidized by increasing the payout of its outcome shares. The system can destroy points in one occasion: Market resolution . The automated market maker of a market holds a pool of outcome shares, which may become valuable when the market resolves. Since no user held these outcome shares, the points are removed by the system.","title":"Assets"},{"location":"assets/#assets","text":"There are two kinds of asset in Hanson: Points , the native currency, denoted with symbol \u201cpt\u201d. Points have no (intrinsic) value in the real world, they are virtual internet points. If Hanson were a real-money prediction market, the currency might have been Euros or Bitcoin. Outcome shares . Outcome shares are associated with a particular market. When the market resolves, outcome shares for the actual outcome will be converted into points, while the shares for the other outcomes become worthless. For every market, there is an exchange rate between outcome shares and points. It starts out at 1:1, but outcome shares can become more valuable due to subsidies. Outcome shares can be created from and destroyed for points, but only in equal quantities. For example, in a binary market with Y and N outcomes and 1:1 exchange rate, we can convert 1 pt into 1 Y + 1 N, and vice versa. This is because when the market resolves, either Y will become worth 1 pt and N worthless, or N will become worth 1 pt and Y worthless, so if you have 1 Y and 1 N, you effectively have 1 pt. Points can only be created by the system. The system creates points for two reasons: Income . Every user gets some points every day, to participate in the markets and create new ones. Think of it as pocket money, an allowance, or a basic income. Subsidies . Good markets can be subsidized by increasing the payout of its outcome shares. The system can destroy points in one occasion: Market resolution . The automated market maker of a market holds a pool of outcome shares, which may become valuable when the market resolves. Since no user held these outcome shares, the points are removed by the system.","title":"Assets"},{"location":"development/","text":"Development guide \u00b6 Hanson is written in Python and uses Postgres as its database. Development environment \u00b6 To enter a development environment with the right version of Postgres, Python, Python packages, and axiliary tools in scope, you can use Nix version 2.11 . If you haven\u2019t already, enable flake support by adding the following line to your ~/.config/nix/nix.conf : experimental-features = nix-command flakes Then enter a development shell with nix develop --command $SHELL Database setup \u00b6 The development environment includes a pinned version of Postgres. The script tools/run_postgres.py starts a sufficiently configured Postgres process that listens on a domain socket. Start one that puts its data in run/db_dev : tools/run_postgres.py --force-init run/db_dev Then in a different shell, perform the initial setup that creates the database and users, and then run all migrations to populate the schema: export PGHOST=\"$PWD/run/db_dev\" tools/migrate.py setup tools/migrate.py migrate latest After this you can Ctrl + C the Postgres process in the other shell. You will not need to start it manually any more, see also Running the application below. The development shell by defaults sets the PGDATABASE , PGUSER , and PGPASSWORD environment variables. If you export PGHOST=$PWD/run/db_dev , then psql can be used directly to inspect the database. Migrations \u00b6 The repository includes a simple migration tool, tools/migrate.py . It loads migrations from the migrations directory. Migrations must be .sql files whose filename starts with a 4-digit sequence number. Each constists of an upgrade and downgrade section as indicated with a comment: -- migrate:up CREATE TABLE \"...\"; -- migrate:down DROP TABLE \"...\"; The migration tool stores the current schema version in the _schema_migrations table. Run tools/migrate.py --help for more information. Running the application \u00b6 The repository contains a Procfile that defines all processes needed to run Hanson (Postgres and Flask). The development environment includes Overmind which can start all processes in the Procfile, and which interleaves their output on stdout. To bring everything up: overmind start By default Flask listens on localhost:5000 . However, the database does not contain any users or interesting data. To fill it with two dummy users and a few demo markets, use the dummy data script: hanson/util/dummy_data.py After this you can log in as henk or piet . Running tests \u00b6 Run the tests: python -m pytest tests The tests will use an independent database at run/db_test , so the tests do not interfere with the development database. The tests start this Postgres instance in the test fixture, so this does not depend on any daemon to be running. Typechecking \u00b6 Typecheck with Mypy : mypy --strict hanson tools tests","title":"Development guide"},{"location":"development/#development-guide","text":"Hanson is written in Python and uses Postgres as its database.","title":"Development guide"},{"location":"development/#development-environment","text":"To enter a development environment with the right version of Postgres, Python, Python packages, and axiliary tools in scope, you can use Nix version 2.11 . If you haven\u2019t already, enable flake support by adding the following line to your ~/.config/nix/nix.conf : experimental-features = nix-command flakes Then enter a development shell with nix develop --command $SHELL","title":"Development environment"},{"location":"development/#database-setup","text":"The development environment includes a pinned version of Postgres. The script tools/run_postgres.py starts a sufficiently configured Postgres process that listens on a domain socket. Start one that puts its data in run/db_dev : tools/run_postgres.py --force-init run/db_dev Then in a different shell, perform the initial setup that creates the database and users, and then run all migrations to populate the schema: export PGHOST=\"$PWD/run/db_dev\" tools/migrate.py setup tools/migrate.py migrate latest After this you can Ctrl + C the Postgres process in the other shell. You will not need to start it manually any more, see also Running the application below. The development shell by defaults sets the PGDATABASE , PGUSER , and PGPASSWORD environment variables. If you export PGHOST=$PWD/run/db_dev , then psql can be used directly to inspect the database.","title":"Database setup"},{"location":"development/#migrations","text":"The repository includes a simple migration tool, tools/migrate.py . It loads migrations from the migrations directory. Migrations must be .sql files whose filename starts with a 4-digit sequence number. Each constists of an upgrade and downgrade section as indicated with a comment: -- migrate:up CREATE TABLE \"...\"; -- migrate:down DROP TABLE \"...\"; The migration tool stores the current schema version in the _schema_migrations table. Run tools/migrate.py --help for more information.","title":"Migrations"},{"location":"development/#running-the-application","text":"The repository contains a Procfile that defines all processes needed to run Hanson (Postgres and Flask). The development environment includes Overmind which can start all processes in the Procfile, and which interleaves their output on stdout. To bring everything up: overmind start By default Flask listens on localhost:5000 . However, the database does not contain any users or interesting data. To fill it with two dummy users and a few demo markets, use the dummy data script: hanson/util/dummy_data.py After this you can log in as henk or piet .","title":"Running the application"},{"location":"development/#running-tests","text":"Run the tests: python -m pytest tests The tests will use an independent database at run/db_test , so the tests do not interfere with the development database. The tests start this Postgres instance in the test fixture, so this does not depend on any daemon to be running.","title":"Running tests"},{"location":"development/#typechecking","text":"Typecheck with Mypy : mypy --strict hanson tools tests","title":"Typechecking"},{"location":"transactions/","text":"Transactions \u00b6 Assets in Hanson can move from one account to another through transactions . There are several types of transactions: Income , when the system creates new points to increase a user\u2019s balance. Exchange , when points are converted into outcome shares, or vice versa. Trade , when a user trades outcome shares against an AMM . The AMM only trades in outcome shares, but if a user doesn\u2019t have the right outcome shares to pay with, then they need to perform an exchange transaction before the trade. The system will do this automatically. Similarly, after a trade, a user might end up with a complete set of outcome shares. The system automatically exchanges those back to points. This ensures that only users who have a position in the market benefit from subsidies. Exchange is only possible for markets that are not yet resolved. Subsidize , when the system creates new points to increase a market\u2019s capitalization, without creating additional outcome shares. This affects the exchange rate for that market by making the outcome shares more valuable. Resolve , when a market resolves, and the value of the outcome shares becomes known. In this transaction, the points that were allocated to the market\u2019s capitalization are distributed over the users who hold outcome shares in the realized outcome. The opposite happens in case of an unresolve. A transaction consists of one or more mutations . A mutation is a change in balance for a particular account.","title":"Transactions"},{"location":"transactions/#transactions","text":"Assets in Hanson can move from one account to another through transactions . There are several types of transactions: Income , when the system creates new points to increase a user\u2019s balance. Exchange , when points are converted into outcome shares, or vice versa. Trade , when a user trades outcome shares against an AMM . The AMM only trades in outcome shares, but if a user doesn\u2019t have the right outcome shares to pay with, then they need to perform an exchange transaction before the trade. The system will do this automatically. Similarly, after a trade, a user might end up with a complete set of outcome shares. The system automatically exchanges those back to points. This ensures that only users who have a position in the market benefit from subsidies. Exchange is only possible for markets that are not yet resolved. Subsidize , when the system creates new points to increase a market\u2019s capitalization, without creating additional outcome shares. This affects the exchange rate for that market by making the outcome shares more valuable. Resolve , when a market resolves, and the value of the outcome shares becomes known. In this transaction, the points that were allocated to the market\u2019s capitalization are distributed over the users who hold outcome shares in the realized outcome. The opposite happens in case of an unresolve. A transaction consists of one or more mutations . A mutation is a change in balance for a particular account.","title":"Transactions"},{"location":"theme/","text":"Kilsbergen \u00b6 A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos \u00b6 Musium documentation Noblit documentation Pris documentation Squiller documentation Tako documentation Features \u00b6 Responsive design Zero javascript Usage \u00b6 One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme: name: null custom_dir: docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug . To enable anchors next to section headings, add the following to your mkdocs.yml : markdown_extensions: - toc: permalink: true permalink_title: null To enable syntax highlighting, ensure that pygmentize is available, and add the following to your mkdocs.yml : markdown_extensions: - codehilite See also the python-markdown list of extensions . License \u00b6 Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"theme/#demos","text":"Musium documentation Noblit documentation Pris documentation Squiller documentation Tako documentation","title":"Demos"},{"location":"theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"theme/#usage","text":"One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme: name: null custom_dir: docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug . To enable anchors next to section headings, add the following to your mkdocs.yml : markdown_extensions: - toc: permalink: true permalink_title: null To enable syntax highlighting, ensure that pygmentize is available, and add the following to your mkdocs.yml : markdown_extensions: - codehilite See also the python-markdown list of extensions .","title":"Usage"},{"location":"theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}